/*
 * generated by Xtext
 */
package de.sos.etj.serializer;

import com.google.inject.Inject;
import com.google.inject.Provider;
import de.sos.etj.eTJ.Account;
import de.sos.etj.eTJ.AccountPrefix;
import de.sos.etj.eTJ.AccountRoot;
import de.sos.etj.eTJ.AccountShare;
import de.sos.etj.eTJ.Alert;
import de.sos.etj.eTJ.Allocate;
import de.sos.etj.eTJ.AllocateResource;
import de.sos.etj.eTJ.Alternative;
import de.sos.etj.eTJ.Author;
import de.sos.etj.eTJ.Balance;
import de.sos.etj.eTJ.Booking;
import de.sos.etj.eTJ.BookingResource;
import de.sos.etj.eTJ.BookingTask;
import de.sos.etj.eTJ.CellColor;
import de.sos.etj.eTJ.CellText;
import de.sos.etj.eTJ.Charge;
import de.sos.etj.eTJ.ChargeSet;
import de.sos.etj.eTJ.Column;
import de.sos.etj.eTJ.Columns;
import de.sos.etj.eTJ.Complete;
import de.sos.etj.eTJ.Copyright;
import de.sos.etj.eTJ.Credit;
import de.sos.etj.eTJ.Criterion;
import de.sos.etj.eTJ.Currency;
import de.sos.etj.eTJ.DailyWorkingHours;
import de.sos.etj.eTJ.Definitions;
import de.sos.etj.eTJ.Defintions;
import de.sos.etj.eTJ.Depends;
import de.sos.etj.eTJ.Duration;
import de.sos.etj.eTJ.DurationQuantity;
import de.sos.etj.eTJ.ETJPackage;
import de.sos.etj.eTJ.Efficiency;
import de.sos.etj.eTJ.Effort;
import de.sos.etj.eTJ.Email;
import de.sos.etj.eTJ.End;
import de.sos.etj.eTJ.EndCredit;
import de.sos.etj.eTJ.Export;
import de.sos.etj.eTJ.Extend;
import de.sos.etj.eTJ.ExtendResource;
import de.sos.etj.eTJ.ExtendTask;
import de.sos.etj.eTJ.ExtendedResourceAttribute;
import de.sos.etj.eTJ.ExtendedResourceAttributeColumn;
import de.sos.etj.eTJ.ExtendedTaskAttribute;
import de.sos.etj.eTJ.Fail;
import de.sos.etj.eTJ.Flags;
import de.sos.etj.eTJ.FontColor;
import de.sos.etj.eTJ.Formats;
import de.sos.etj.eTJ.Function;
import de.sos.etj.eTJ.Global;
import de.sos.etj.eTJ.HAlign;
import de.sos.etj.eTJ.HideAccount;
import de.sos.etj.eTJ.HideJournalEntry;
import de.sos.etj.eTJ.HideReport;
import de.sos.etj.eTJ.HideResource;
import de.sos.etj.eTJ.HideTask;
import de.sos.etj.eTJ.ISODATE;
import de.sos.etj.eTJ.IcalReport;
import de.sos.etj.eTJ.Include;
import de.sos.etj.eTJ.IncludeProperties;
import de.sos.etj.eTJ.Interval1;
import de.sos.etj.eTJ.Interval2;
import de.sos.etj.eTJ.Interval3;
import de.sos.etj.eTJ.Interval4;
import de.sos.etj.eTJ.JournalAttributes;
import de.sos.etj.eTJ.JournalEntry;
import de.sos.etj.eTJ.JournalMode;
import de.sos.etj.eTJ.LeaveDetails;
import de.sos.etj.eTJ.Leaves;
import de.sos.etj.eTJ.Length;
import de.sos.etj.eTJ.Limit;
import de.sos.etj.eTJ.LimitAttribute;
import de.sos.etj.eTJ.Limits;
import de.sos.etj.eTJ.ListType;
import de.sos.etj.eTJ.LoadUnit;
import de.sos.etj.eTJ.LogicalAbsoluteIdExression;
import de.sos.etj.eTJ.LogicalBooleanLiteral;
import de.sos.etj.eTJ.LogicalDateLiteral;
import de.sos.etj.eTJ.LogicalExpression;
import de.sos.etj.eTJ.LogicalFlagExpression;
import de.sos.etj.eTJ.LogicalFunctionExpression;
import de.sos.etj.eTJ.LogicalNumeralLiteral;
import de.sos.etj.eTJ.LogicalStringLiteral;
import de.sos.etj.eTJ.Macro;
import de.sos.etj.eTJ.MacroCall;
import de.sos.etj.eTJ.Managers;
import de.sos.etj.eTJ.Mandatory;
import de.sos.etj.eTJ.MaxEnd;
import de.sos.etj.eTJ.MaxStart;
import de.sos.etj.eTJ.Milestone;
import de.sos.etj.eTJ.MinEnd;
import de.sos.etj.eTJ.MinStart;
import de.sos.etj.eTJ.Navigator;
import de.sos.etj.eTJ.NewTask;
import de.sos.etj.eTJ.NikuReport;
import de.sos.etj.eTJ.Note;
import de.sos.etj.eTJ.Now;
import de.sos.etj.eTJ.Period;
import de.sos.etj.eTJ.Persistent;
import de.sos.etj.eTJ.Priority;
import de.sos.etj.eTJ.Project;
import de.sos.etj.eTJ.ProjectId;
import de.sos.etj.eTJ.ProjectIds;
import de.sos.etj.eTJ.PurgeReport;
import de.sos.etj.eTJ.PurgeResource;
import de.sos.etj.eTJ.PurgeTask;
import de.sos.etj.eTJ.RGB;
import de.sos.etj.eTJ.Rate;
import de.sos.etj.eTJ.RealFormat;
import de.sos.etj.eTJ.Remaining;
import de.sos.etj.eTJ.Report;
import de.sos.etj.eTJ.ReportPrefix;
import de.sos.etj.eTJ.Resource;
import de.sos.etj.eTJ.ResourceAttributes;
import de.sos.etj.eTJ.ResourcePrefix;
import de.sos.etj.eTJ.ResourceRoot;
import de.sos.etj.eTJ.Responsible;
import de.sos.etj.eTJ.RichText;
import de.sos.etj.eTJ.RollupAccount;
import de.sos.etj.eTJ.RollupResource;
import de.sos.etj.eTJ.RollupTask;
import de.sos.etj.eTJ.Scale;
import de.sos.etj.eTJ.Scenario;
import de.sos.etj.eTJ.ScenarioIcal;
import de.sos.etj.eTJ.Scenarios;
import de.sos.etj.eTJ.Scheduled;
import de.sos.etj.eTJ.Scheduling;
import de.sos.etj.eTJ.Select;
import de.sos.etj.eTJ.SelfContained;
import de.sos.etj.eTJ.Shift;
import de.sos.etj.eTJ.ShiftTimesheet;
import de.sos.etj.eTJ.Shifts;
import de.sos.etj.eTJ.ShiftsAllocate;
import de.sos.etj.eTJ.ShiftsLimit;
import de.sos.etj.eTJ.ShortTimeFormat;
import de.sos.etj.eTJ.Sort;
import de.sos.etj.eTJ.Start;
import de.sos.etj.eTJ.StatusSheet;
import de.sos.etj.eTJ.StatusSheetReport;
import de.sos.etj.eTJ.StatusStatusSheet;
import de.sos.etj.eTJ.StatusTimesheet;
import de.sos.etj.eTJ.SupplementAccount;
import de.sos.etj.eTJ.SupplementReport;
import de.sos.etj.eTJ.SupplementResource;
import de.sos.etj.eTJ.SupplementTask;
import de.sos.etj.eTJ.TagFile;
import de.sos.etj.eTJ.Task;
import de.sos.etj.eTJ.TaskAttribute;
import de.sos.etj.eTJ.TaskAttributes;
import de.sos.etj.eTJ.TaskDependency;
import de.sos.etj.eTJ.TaskPrefix;
import de.sos.etj.eTJ.TaskRoot;
import de.sos.etj.eTJ.TaskStatusSheet;
import de.sos.etj.eTJ.TaskTimesheet;
import de.sos.etj.eTJ.TimeFormat;
import de.sos.etj.eTJ.Timeoff;
import de.sos.etj.eTJ.Timesheet;
import de.sos.etj.eTJ.TimesheetReport;
import de.sos.etj.eTJ.Timezone;
import de.sos.etj.eTJ.TimingResolution;
import de.sos.etj.eTJ.Title;
import de.sos.etj.eTJ.ToolTip;
import de.sos.etj.eTJ.TrackingScenario;
import de.sos.etj.eTJ.TreeLevel;
import de.sos.etj.eTJ.Vacation;
import de.sos.etj.eTJ.Warn;
import de.sos.etj.eTJ.WeekStarts;
import de.sos.etj.eTJ.Weekdays;
import de.sos.etj.eTJ.Width;
import de.sos.etj.eTJ.Work;
import de.sos.etj.eTJ.WorkHours;
import de.sos.etj.eTJ.WorkingHours;
import de.sos.etj.eTJ.YearlyWorkingDays;
import de.sos.etj.services.ETJGrammarAccess;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.xtext.serializer.acceptor.ISemanticSequenceAcceptor;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.diagnostic.ISemanticSequencerDiagnosticProvider;
import org.eclipse.xtext.serializer.diagnostic.ISerializationDiagnostic.Acceptor;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.GenericSequencer;
import org.eclipse.xtext.serializer.sequencer.ISemanticNodeProvider.INodesForEObjectProvider;
import org.eclipse.xtext.serializer.sequencer.ISemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public abstract class AbstractETJSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private ETJGrammarAccess grammarAccess;
	
	@Override
	public void createSequence(EObject context, EObject semanticObject) {
		if(semanticObject.eClass().getEPackage() == ETJPackage.eINSTANCE) switch(semanticObject.eClass().getClassifierID()) {
			case ETJPackage.ACCOUNT:
				sequence_Account(context, (Account) semanticObject); 
				return; 
			case ETJPackage.ACCOUNT_PREFIX:
				sequence_AccountPrefix(context, (AccountPrefix) semanticObject); 
				return; 
			case ETJPackage.ACCOUNT_ROOT:
				sequence_AccountRoot(context, (AccountRoot) semanticObject); 
				return; 
			case ETJPackage.ACCOUNT_SHARE:
				sequence_AccountShare(context, (AccountShare) semanticObject); 
				return; 
			case ETJPackage.ALERT:
				sequence_Alert(context, (Alert) semanticObject); 
				return; 
			case ETJPackage.ALLOCATE:
				sequence_Allocate(context, (Allocate) semanticObject); 
				return; 
			case ETJPackage.ALLOCATE_RESOURCE:
				sequence_AllocateResource(context, (AllocateResource) semanticObject); 
				return; 
			case ETJPackage.ALTERNATIVE:
				sequence_Alternative(context, (Alternative) semanticObject); 
				return; 
			case ETJPackage.AUTHOR:
				sequence_Author(context, (Author) semanticObject); 
				return; 
			case ETJPackage.BALANCE:
				sequence_Balance(context, (Balance) semanticObject); 
				return; 
			case ETJPackage.BOOKING:
				sequence_Booking(context, (Booking) semanticObject); 
				return; 
			case ETJPackage.BOOKING_RESOURCE:
				sequence_BookingResource(context, (BookingResource) semanticObject); 
				return; 
			case ETJPackage.BOOKING_TASK:
				sequence_BookingTask(context, (BookingTask) semanticObject); 
				return; 
			case ETJPackage.CELL_COLOR:
				sequence_CellColor(context, (CellColor) semanticObject); 
				return; 
			case ETJPackage.CELL_TEXT:
				sequence_CellText(context, (CellText) semanticObject); 
				return; 
			case ETJPackage.CHARGE:
				sequence_Charge(context, (Charge) semanticObject); 
				return; 
			case ETJPackage.CHARGE_SET:
				sequence_ChargeSet(context, (ChargeSet) semanticObject); 
				return; 
			case ETJPackage.COLUMN:
				sequence_Column(context, (Column) semanticObject); 
				return; 
			case ETJPackage.COLUMNS:
				sequence_Columns(context, (Columns) semanticObject); 
				return; 
			case ETJPackage.COMPLETE:
				sequence_Complete(context, (Complete) semanticObject); 
				return; 
			case ETJPackage.COPYRIGHT:
				sequence_Copyright(context, (Copyright) semanticObject); 
				return; 
			case ETJPackage.CREDIT:
				sequence_Credit(context, (Credit) semanticObject); 
				return; 
			case ETJPackage.CRITERION:
				sequence_Criterion(context, (Criterion) semanticObject); 
				return; 
			case ETJPackage.CURRENCY:
				sequence_Currency(context, (Currency) semanticObject); 
				return; 
			case ETJPackage.DAILY_WORKING_HOURS:
				sequence_DailyWorkingHours(context, (DailyWorkingHours) semanticObject); 
				return; 
			case ETJPackage.DEFINITIONS:
				sequence_Definitions(context, (Definitions) semanticObject); 
				return; 
			case ETJPackage.DEFINTIONS:
				sequence_Definitions(context, (Defintions) semanticObject); 
				return; 
			case ETJPackage.DEPENDS:
				sequence_Depends(context, (Depends) semanticObject); 
				return; 
			case ETJPackage.DURATION:
				sequence_Duration(context, (Duration) semanticObject); 
				return; 
			case ETJPackage.DURATION_QUANTITY:
				sequence_DurationQuantity(context, (DurationQuantity) semanticObject); 
				return; 
			case ETJPackage.EFFICIENCY:
				sequence_Efficiency(context, (Efficiency) semanticObject); 
				return; 
			case ETJPackage.EFFORT:
				sequence_Effort(context, (Effort) semanticObject); 
				return; 
			case ETJPackage.EMAIL:
				sequence_Email(context, (Email) semanticObject); 
				return; 
			case ETJPackage.END:
				sequence_End(context, (End) semanticObject); 
				return; 
			case ETJPackage.END_CREDIT:
				sequence_EndCredit(context, (EndCredit) semanticObject); 
				return; 
			case ETJPackage.EXPORT:
				sequence_Export(context, (Export) semanticObject); 
				return; 
			case ETJPackage.EXTEND:
				sequence_Extend(context, (Extend) semanticObject); 
				return; 
			case ETJPackage.EXTEND_RESOURCE:
				sequence_ExtendResource(context, (ExtendResource) semanticObject); 
				return; 
			case ETJPackage.EXTEND_TASK:
				sequence_ExtendTask(context, (ExtendTask) semanticObject); 
				return; 
			case ETJPackage.EXTENDED_RESOURCE_ATTRIBUTE:
				sequence_ExtendedResourceAttribute(context, (ExtendedResourceAttribute) semanticObject); 
				return; 
			case ETJPackage.EXTENDED_RESOURCE_ATTRIBUTE_COLUMN:
				sequence_ExtendedResourceAttributeColumn(context, (ExtendedResourceAttributeColumn) semanticObject); 
				return; 
			case ETJPackage.EXTENDED_TASK_ATTRIBUTE:
				sequence_ExtendedTaskAttribute(context, (ExtendedTaskAttribute) semanticObject); 
				return; 
			case ETJPackage.FAIL:
				sequence_Fail(context, (Fail) semanticObject); 
				return; 
			case ETJPackage.FLAGS:
				sequence_Flags(context, (Flags) semanticObject); 
				return; 
			case ETJPackage.FONT_COLOR:
				sequence_FontColor(context, (FontColor) semanticObject); 
				return; 
			case ETJPackage.FORMATS:
				sequence_Formats(context, (Formats) semanticObject); 
				return; 
			case ETJPackage.FUNCTION:
				sequence_Function(context, (Function) semanticObject); 
				return; 
			case ETJPackage.GLOBAL:
				sequence_Global(context, (Global) semanticObject); 
				return; 
			case ETJPackage.HALIGN:
				sequence_HAlign(context, (HAlign) semanticObject); 
				return; 
			case ETJPackage.HIDE_ACCOUNT:
				sequence_HideAccount(context, (HideAccount) semanticObject); 
				return; 
			case ETJPackage.HIDE_JOURNAL_ENTRY:
				sequence_HideJournalEntry(context, (HideJournalEntry) semanticObject); 
				return; 
			case ETJPackage.HIDE_REPORT:
				sequence_HideReport(context, (HideReport) semanticObject); 
				return; 
			case ETJPackage.HIDE_RESOURCE:
				sequence_HideResource(context, (HideResource) semanticObject); 
				return; 
			case ETJPackage.HIDE_TASK:
				sequence_HideTask(context, (HideTask) semanticObject); 
				return; 
			case ETJPackage.ISODATE:
				sequence_ISODATE(context, (ISODATE) semanticObject); 
				return; 
			case ETJPackage.ICAL_REPORT:
				sequence_IcalReport(context, (IcalReport) semanticObject); 
				return; 
			case ETJPackage.INCLUDE:
				sequence_Include(context, (Include) semanticObject); 
				return; 
			case ETJPackage.INCLUDE_PROPERTIES:
				sequence_IncludeProperties(context, (IncludeProperties) semanticObject); 
				return; 
			case ETJPackage.INTERVAL1:
				sequence_Interval1(context, (Interval1) semanticObject); 
				return; 
			case ETJPackage.INTERVAL2:
				sequence_Interval2(context, (Interval2) semanticObject); 
				return; 
			case ETJPackage.INTERVAL3:
				sequence_Interval3(context, (Interval3) semanticObject); 
				return; 
			case ETJPackage.INTERVAL4:
				sequence_Interval4(context, (Interval4) semanticObject); 
				return; 
			case ETJPackage.JOURNAL_ATTRIBUTES:
				sequence_JournalAttributes(context, (JournalAttributes) semanticObject); 
				return; 
			case ETJPackage.JOURNAL_ENTRY:
				sequence_JournalEntry(context, (JournalEntry) semanticObject); 
				return; 
			case ETJPackage.JOURNAL_MODE:
				sequence_JournalMode(context, (JournalMode) semanticObject); 
				return; 
			case ETJPackage.LEAVE_DETAILS:
				sequence_LeaveDetails(context, (LeaveDetails) semanticObject); 
				return; 
			case ETJPackage.LEAVES:
				sequence_Leaves(context, (Leaves) semanticObject); 
				return; 
			case ETJPackage.LENGTH:
				sequence_Length(context, (Length) semanticObject); 
				return; 
			case ETJPackage.LIMIT:
				sequence_Limit(context, (Limit) semanticObject); 
				return; 
			case ETJPackage.LIMIT_ATTRIBUTE:
				sequence_LimitAttribute(context, (LimitAttribute) semanticObject); 
				return; 
			case ETJPackage.LIMITS:
				sequence_Limits(context, (Limits) semanticObject); 
				return; 
			case ETJPackage.LIST_TYPE:
				sequence_ListType(context, (ListType) semanticObject); 
				return; 
			case ETJPackage.LOAD_UNIT:
				sequence_LoadUnit(context, (LoadUnit) semanticObject); 
				return; 
			case ETJPackage.LOGICAL_ABSOLUTE_ID_EXRESSION:
				sequence_LogicalAbsoluteIdExpression(context, (LogicalAbsoluteIdExression) semanticObject); 
				return; 
			case ETJPackage.LOGICAL_BOOLEAN_LITERAL:
				sequence_LogicalBooleanLiteral(context, (LogicalBooleanLiteral) semanticObject); 
				return; 
			case ETJPackage.LOGICAL_DATE_LITERAL:
				sequence_LogicalISODateLiteral(context, (LogicalDateLiteral) semanticObject); 
				return; 
			case ETJPackage.LOGICAL_EXPRESSION:
				if(context == grammarAccess.getLogicalAndExpressionRule()) {
					sequence_LogicalAndExpression(context, (LogicalExpression) semanticObject); 
					return; 
				}
				else if(context == grammarAccess.getLogicalEqualityExpressionRule()) {
					sequence_LogicalEqualityExpression(context, (LogicalExpression) semanticObject); 
					return; 
				}
				else if(context == grammarAccess.getLogicalExpressionRule() ||
				   context == grammarAccess.getLogicalOrExpressionRule() ||
				   context == grammarAccess.getLogicalPrenthesizedExpressionRule() ||
				   context == grammarAccess.getLogicalPrimaryExpressionRule()) {
					sequence_LogicalOrExpression(context, (LogicalExpression) semanticObject); 
					return; 
				}
				else if(context == grammarAccess.getLogicalRelationalExpressionRule()) {
					sequence_LogicalRelationalExpression(context, (LogicalExpression) semanticObject); 
					return; 
				}
				else break;
			case ETJPackage.LOGICAL_FLAG_EXPRESSION:
				sequence_LogicalFlagLiteral(context, (LogicalFlagExpression) semanticObject); 
				return; 
			case ETJPackage.LOGICAL_FUNCTION_EXPRESSION:
				sequence_LogicalFunctionExpression(context, (LogicalFunctionExpression) semanticObject); 
				return; 
			case ETJPackage.LOGICAL_NUMERAL_LITERAL:
				sequence_LogicalNumeralLiteral(context, (LogicalNumeralLiteral) semanticObject); 
				return; 
			case ETJPackage.LOGICAL_STRING_LITERAL:
				sequence_LogicalStringLiteral(context, (LogicalStringLiteral) semanticObject); 
				return; 
			case ETJPackage.MACRO:
				sequence_Macro(context, (Macro) semanticObject); 
				return; 
			case ETJPackage.MACRO_CALL:
				sequence_MacroCall(context, (MacroCall) semanticObject); 
				return; 
			case ETJPackage.MANAGERS:
				sequence_Managers(context, (Managers) semanticObject); 
				return; 
			case ETJPackage.MANDATORY:
				sequence_Mandatory(context, (Mandatory) semanticObject); 
				return; 
			case ETJPackage.MAX_END:
				sequence_MaxEnd(context, (MaxEnd) semanticObject); 
				return; 
			case ETJPackage.MAX_START:
				sequence_MaxStart(context, (MaxStart) semanticObject); 
				return; 
			case ETJPackage.MILESTONE:
				sequence_Milestone(context, (Milestone) semanticObject); 
				return; 
			case ETJPackage.MIN_END:
				sequence_MinEnd(context, (MinEnd) semanticObject); 
				return; 
			case ETJPackage.MIN_START:
				sequence_MinStart(context, (MinStart) semanticObject); 
				return; 
			case ETJPackage.NAVIGATOR:
				sequence_Navigator(context, (Navigator) semanticObject); 
				return; 
			case ETJPackage.NEW_TASK:
				sequence_NewTask(context, (NewTask) semanticObject); 
				return; 
			case ETJPackage.NIKU_REPORT:
				sequence_NikuReport(context, (NikuReport) semanticObject); 
				return; 
			case ETJPackage.NOTE:
				sequence_Note(context, (Note) semanticObject); 
				return; 
			case ETJPackage.NOW:
				sequence_Now(context, (Now) semanticObject); 
				return; 
			case ETJPackage.PERIOD:
				sequence_Period(context, (Period) semanticObject); 
				return; 
			case ETJPackage.PERSISTENT:
				sequence_Persistent(context, (Persistent) semanticObject); 
				return; 
			case ETJPackage.PRIORITY:
				sequence_Priority(context, (Priority) semanticObject); 
				return; 
			case ETJPackage.PROJECT:
				sequence_Project(context, (Project) semanticObject); 
				return; 
			case ETJPackage.PROJECT_ID:
				sequence_ProjectId(context, (ProjectId) semanticObject); 
				return; 
			case ETJPackage.PROJECT_IDS:
				sequence_ProjectIds(context, (ProjectIds) semanticObject); 
				return; 
			case ETJPackage.PURGE_REPORT:
				sequence_PurgeReport(context, (PurgeReport) semanticObject); 
				return; 
			case ETJPackage.PURGE_RESOURCE:
				sequence_PurgeResource(context, (PurgeResource) semanticObject); 
				return; 
			case ETJPackage.PURGE_TASK:
				sequence_PurgeTask(context, (PurgeTask) semanticObject); 
				return; 
			case ETJPackage.RGB:
				sequence_RGB(context, (RGB) semanticObject); 
				return; 
			case ETJPackage.RATE:
				sequence_Rate(context, (Rate) semanticObject); 
				return; 
			case ETJPackage.REAL_FORMAT:
				sequence_RealFormat(context, (RealFormat) semanticObject); 
				return; 
			case ETJPackage.REMAINING:
				sequence_Remaining(context, (Remaining) semanticObject); 
				return; 
			case ETJPackage.REPORT:
				sequence_Report(context, (Report) semanticObject); 
				return; 
			case ETJPackage.REPORT_PREFIX:
				sequence_ReportPrefix(context, (ReportPrefix) semanticObject); 
				return; 
			case ETJPackage.RESOURCE:
				sequence_Resource(context, (Resource) semanticObject); 
				return; 
			case ETJPackage.RESOURCE_ATTRIBUTES:
				sequence_ResourceAttributes(context, (ResourceAttributes) semanticObject); 
				return; 
			case ETJPackage.RESOURCE_PREFIX:
				sequence_ResourcePrefix(context, (ResourcePrefix) semanticObject); 
				return; 
			case ETJPackage.RESOURCE_ROOT:
				sequence_ResourceRoot(context, (ResourceRoot) semanticObject); 
				return; 
			case ETJPackage.RESPONSIBLE:
				sequence_Responsible(context, (Responsible) semanticObject); 
				return; 
			case ETJPackage.RICH_TEXT:
				sequence_RichText(context, (RichText) semanticObject); 
				return; 
			case ETJPackage.ROLLUP_ACCOUNT:
				sequence_RollupAccount(context, (RollupAccount) semanticObject); 
				return; 
			case ETJPackage.ROLLUP_RESOURCE:
				sequence_RollupResource(context, (RollupResource) semanticObject); 
				return; 
			case ETJPackage.ROLLUP_TASK:
				sequence_RollupTask(context, (RollupTask) semanticObject); 
				return; 
			case ETJPackage.SCALE:
				sequence_Scale(context, (Scale) semanticObject); 
				return; 
			case ETJPackage.SCENARIO:
				sequence_Scenario(context, (Scenario) semanticObject); 
				return; 
			case ETJPackage.SCENARIO_ICAL:
				sequence_ScenarioIcal(context, (ScenarioIcal) semanticObject); 
				return; 
			case ETJPackage.SCENARIOS:
				sequence_Scenarios(context, (Scenarios) semanticObject); 
				return; 
			case ETJPackage.SCHEDULED:
				sequence_Scheduled(context, (Scheduled) semanticObject); 
				return; 
			case ETJPackage.SCHEDULING:
				sequence_Scheduling(context, (Scheduling) semanticObject); 
				return; 
			case ETJPackage.SELECT:
				sequence_Select(context, (Select) semanticObject); 
				return; 
			case ETJPackage.SELF_CONTAINED:
				sequence_SelfContained(context, (SelfContained) semanticObject); 
				return; 
			case ETJPackage.SHIFT:
				sequence_Shift(context, (Shift) semanticObject); 
				return; 
			case ETJPackage.SHIFT_TIMESHEET:
				sequence_ShiftTimesheet(context, (ShiftTimesheet) semanticObject); 
				return; 
			case ETJPackage.SHIFTS:
				sequence_Shifts(context, (Shifts) semanticObject); 
				return; 
			case ETJPackage.SHIFTS_ALLOCATE:
				sequence_ShiftsAllocate(context, (ShiftsAllocate) semanticObject); 
				return; 
			case ETJPackage.SHIFTS_LIMIT:
				sequence_ShiftsLimit(context, (ShiftsLimit) semanticObject); 
				return; 
			case ETJPackage.SHORT_TIME_FORMAT:
				sequence_ShortTimeFormat(context, (ShortTimeFormat) semanticObject); 
				return; 
			case ETJPackage.SORT:
				sequence_Sort(context, (Sort) semanticObject); 
				return; 
			case ETJPackage.START:
				sequence_Start(context, (Start) semanticObject); 
				return; 
			case ETJPackage.STATUS_SHEET:
				sequence_StatusSheet(context, (StatusSheet) semanticObject); 
				return; 
			case ETJPackage.STATUS_SHEET_REPORT:
				sequence_StatusSheetReport(context, (StatusSheetReport) semanticObject); 
				return; 
			case ETJPackage.STATUS_STATUS_SHEET:
				sequence_StatusStatusSheet(context, (StatusStatusSheet) semanticObject); 
				return; 
			case ETJPackage.STATUS_TIMESHEET:
				sequence_StatusTimesheet(context, (StatusTimesheet) semanticObject); 
				return; 
			case ETJPackage.SUPPLEMENT_ACCOUNT:
				sequence_SupplementAccount(context, (SupplementAccount) semanticObject); 
				return; 
			case ETJPackage.SUPPLEMENT_REPORT:
				sequence_SupplementReport(context, (SupplementReport) semanticObject); 
				return; 
			case ETJPackage.SUPPLEMENT_RESOURCE:
				sequence_SupplementResource(context, (SupplementResource) semanticObject); 
				return; 
			case ETJPackage.SUPPLEMENT_TASK:
				sequence_SupplementTask(context, (SupplementTask) semanticObject); 
				return; 
			case ETJPackage.TAG_FILE:
				sequence_TagFile(context, (TagFile) semanticObject); 
				return; 
			case ETJPackage.TASK:
				sequence_Task(context, (Task) semanticObject); 
				return; 
			case ETJPackage.TASK_ATTRIBUTE:
				sequence_TaskAttribute(context, (TaskAttribute) semanticObject); 
				return; 
			case ETJPackage.TASK_ATTRIBUTES:
				sequence_TaskAttributes(context, (TaskAttributes) semanticObject); 
				return; 
			case ETJPackage.TASK_DEPENDENCY:
				sequence_TaskDependency(context, (TaskDependency) semanticObject); 
				return; 
			case ETJPackage.TASK_PREFIX:
				sequence_TaskPrefix(context, (TaskPrefix) semanticObject); 
				return; 
			case ETJPackage.TASK_ROOT:
				sequence_TaskRoot(context, (TaskRoot) semanticObject); 
				return; 
			case ETJPackage.TASK_STATUS_SHEET:
				sequence_TaskStatusSheet(context, (TaskStatusSheet) semanticObject); 
				return; 
			case ETJPackage.TASK_TIMESHEET:
				sequence_TaskTimesheet(context, (TaskTimesheet) semanticObject); 
				return; 
			case ETJPackage.TIME_FORMAT:
				sequence_TimeFormat(context, (TimeFormat) semanticObject); 
				return; 
			case ETJPackage.TIMEOFF:
				sequence_Timeoff(context, (Timeoff) semanticObject); 
				return; 
			case ETJPackage.TIMESHEET:
				sequence_Timesheet(context, (Timesheet) semanticObject); 
				return; 
			case ETJPackage.TIMESHEET_REPORT:
				sequence_TimesheetReport(context, (TimesheetReport) semanticObject); 
				return; 
			case ETJPackage.TIMEZONE:
				sequence_Timezone(context, (Timezone) semanticObject); 
				return; 
			case ETJPackage.TIMING_RESOLUTION:
				sequence_TimingResolution(context, (TimingResolution) semanticObject); 
				return; 
			case ETJPackage.TITLE:
				sequence_Title(context, (Title) semanticObject); 
				return; 
			case ETJPackage.TOOL_TIP:
				sequence_ToolTip(context, (ToolTip) semanticObject); 
				return; 
			case ETJPackage.TRACKING_SCENARIO:
				sequence_TrackingScenario(context, (TrackingScenario) semanticObject); 
				return; 
			case ETJPackage.TREE_LEVEL:
				sequence_TreeLevel(context, (TreeLevel) semanticObject); 
				return; 
			case ETJPackage.VACATION:
				if(context == grammarAccess.getResourceAttributeRule() ||
				   context == grammarAccess.getVacationResourceRule()) {
					sequence_VacationResource(context, (Vacation) semanticObject); 
					return; 
				}
				else if(context == grammarAccess.getVacationShiftRule()) {
					sequence_VacationShift(context, (Vacation) semanticObject); 
					return; 
				}
				else if(context == grammarAccess.getPropertyRule() ||
				   context == grammarAccess.getVacationRule()) {
					sequence_Vacation(context, (Vacation) semanticObject); 
					return; 
				}
				else break;
			case ETJPackage.WARN:
				sequence_Warn(context, (Warn) semanticObject); 
				return; 
			case ETJPackage.WEEK_STARTS:
				sequence_WeekStarts(context, (WeekStarts) semanticObject); 
				return; 
			case ETJPackage.WEEKDAYS:
				sequence_Weekdays(context, (Weekdays) semanticObject); 
				return; 
			case ETJPackage.WIDTH:
				sequence_Width(context, (Width) semanticObject); 
				return; 
			case ETJPackage.WORK:
				sequence_Work(context, (Work) semanticObject); 
				return; 
			case ETJPackage.WORK_HOURS:
				sequence_WorkHours(context, (WorkHours) semanticObject); 
				return; 
			case ETJPackage.WORKING_HOURS:
				sequence_WorkingHours(context, (WorkingHours) semanticObject); 
				return; 
			case ETJPackage.YEARLY_WORKING_DAYS:
				sequence_YearlyWorkingDays(context, (YearlyWorkingDays) semanticObject); 
				return; 
			}
		if (errorAcceptor != null) errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Constraint:
	 *     account=[Account|ID]
	 */
	protected void sequence_AccountPrefix(EObject context, AccountPrefix semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, ETJPackage.eINSTANCE.getAccountPrefix_Account()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ETJPackage.eINSTANCE.getAccountPrefix_Account()));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getAccountPrefixAccess().getAccountAccountIDTerminalRuleCall_1_0_1(), semanticObject.getAccount());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     account=[Account|ID]
	 */
	protected void sequence_AccountRoot(EObject context, AccountRoot semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, ETJPackage.eINSTANCE.getAccountRoot_Account()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ETJPackage.eINSTANCE.getAccountRoot_Account()));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getAccountRootAccess().getAccountAccountIDTerminalRuleCall_1_0_1(), semanticObject.getAccount());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (account=[Account|ID] share=XFloat?)
	 */
	protected void sequence_AccountShare(EObject context, AccountShare semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (id=ID? name=STRING attributes+=AccountAttribute*)
	 */
	protected void sequence_Account(EObject context, Account semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     level=AlertLevel
	 */
	protected void sequence_Alert(EObject context, Alert semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, ETJPackage.eINSTANCE.getAlert_Level()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ETJPackage.eINSTANCE.getAlert_Level()));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getAlertAccess().getLevelAlertLevelEnumRuleCall_1_0(), semanticObject.getLevel());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (resource=[Resource|ID] attributes+=AllocateResourceAttribute*)
	 */
	protected void sequence_AllocateResource(EObject context, AllocateResource semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (resources+=AllocateResource resources+=AllocateResource*)
	 */
	protected void sequence_Allocate(EObject context, Allocate semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (resources+=[Resource|ID] resources+=[Resource|ID]*)
	 */
	protected void sequence_Alternative(EObject context, Alternative semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     resource=[Resource|ID]
	 */
	protected void sequence_Author(EObject context, Author semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, ETJPackage.eINSTANCE.getAuthor_Resource()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ETJPackage.eINSTANCE.getAuthor_Resource()));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getAuthorAccess().getResourceResourceIDTerminalRuleCall_1_0_1(), semanticObject.getResource());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (cost=[Account|ID] revenue=[Account|ID])
	 */
	protected void sequence_Balance(EObject context, Balance semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, ETJPackage.eINSTANCE.getBalance_Cost()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ETJPackage.eINSTANCE.getBalance_Cost()));
			if(transientValues.isValueTransient(semanticObject, ETJPackage.eINSTANCE.getBalance_Revenue()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ETJPackage.eINSTANCE.getBalance_Revenue()));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getBalanceAccess().getCostAccountIDTerminalRuleCall_1_0_1(), semanticObject.getCost());
		feeder.accept(grammarAccess.getBalanceAccess().getRevenueAccountIDTerminalRuleCall_2_0_1(), semanticObject.getRevenue());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (task=[Task|ID] booking=Booking)
	 */
	protected void sequence_BookingResource(EObject context, BookingResource semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, ETJPackage.eINSTANCE.getBookingResource_Task()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ETJPackage.eINSTANCE.getBookingResource_Task()));
			if(transientValues.isValueTransient(semanticObject, ETJPackage.eINSTANCE.getBookingResource_Booking()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ETJPackage.eINSTANCE.getBookingResource_Booking()));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getBookingResourceAccess().getTaskTaskIDTerminalRuleCall_1_0_1(), semanticObject.getTask());
		feeder.accept(grammarAccess.getBookingResourceAccess().getBookingBookingParserRuleCall_2_0(), semanticObject.getBooking());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (resource=[Resource|ID] booking=Booking)
	 */
	protected void sequence_BookingTask(EObject context, BookingTask semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, ETJPackage.eINSTANCE.getBookingTask_Resource()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ETJPackage.eINSTANCE.getBookingTask_Resource()));
			if(transientValues.isValueTransient(semanticObject, ETJPackage.eINSTANCE.getBookingTask_Booking()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ETJPackage.eINSTANCE.getBookingTask_Booking()));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getBookingTaskAccess().getResourceResourceIDTerminalRuleCall_1_0_1(), semanticObject.getResource());
		feeder.accept(grammarAccess.getBookingTaskAccess().getBookingBookingParserRuleCall_2_0(), semanticObject.getBooking());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (interval=Interval4 (overtime=INT? sloppy=INT?)?)
	 */
	protected void sequence_Booking(EObject context, Booking semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (expression=LogicalExpression color=RGB)
	 */
	protected void sequence_CellColor(EObject context, CellColor semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, ETJPackage.eINSTANCE.getCellColor_Expression()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ETJPackage.eINSTANCE.getCellColor_Expression()));
			if(transientValues.isValueTransient(semanticObject, ETJPackage.eINSTANCE.getCellColor_Color()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ETJPackage.eINSTANCE.getCellColor_Color()));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getCellColorAccess().getExpressionLogicalExpressionParserRuleCall_1_0(), semanticObject.getExpression());
		feeder.accept(grammarAccess.getCellColorAccess().getColorRGBParserRuleCall_2_0(), semanticObject.getColor());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (expresssion=LogicalExpression text=STRING)
	 */
	protected void sequence_CellText(EObject context, CellText semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, ETJPackage.eINSTANCE.getCellText_Expresssion()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ETJPackage.eINSTANCE.getCellText_Expresssion()));
			if(transientValues.isValueTransient(semanticObject, ETJPackage.eINSTANCE.getCellText_Text()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ETJPackage.eINSTANCE.getCellText_Text()));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getCellTextAccess().getExpresssionLogicalExpressionParserRuleCall_1_0(), semanticObject.getExpresssion());
		feeder.accept(grammarAccess.getCellTextAccess().getTextSTRINGTerminalRuleCall_2_0(), semanticObject.getText());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (accountShares+=AccountShare accountShares+=AccountShare*)
	 */
	protected void sequence_ChargeSet(EObject context, ChargeSet semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (amount=XFloat applies=ChargeApplies)
	 */
	protected void sequence_Charge(EObject context, Charge semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, ETJPackage.eINSTANCE.getCharge_Amount()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ETJPackage.eINSTANCE.getCharge_Amount()));
			if(transientValues.isValueTransient(semanticObject, ETJPackage.eINSTANCE.getCharge_Applies()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ETJPackage.eINSTANCE.getCharge_Applies()));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getChargeAccess().getAmountXFloatParserRuleCall_1_0(), semanticObject.getAmount());
		feeder.accept(grammarAccess.getChargeAccess().getAppliesChargeAppliesEnumRuleCall_2_0(), semanticObject.getApplies());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     ((id=ColumnId | ext=ExtendedResourceAttributeColumn) attributes+=ColumnAttribute*)
	 */
	protected void sequence_Column(EObject context, Column semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (columns+=Column columns+=Column*)
	 */
	protected void sequence_Columns(EObject context, Columns semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     complete=XFloat
	 */
	protected void sequence_Complete(EObject context, Complete semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, ETJPackage.eINSTANCE.getComplete_Complete()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ETJPackage.eINSTANCE.getComplete_Complete()));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getCompleteAccess().getCompleteXFloatParserRuleCall_1_0(), semanticObject.getComplete());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     text=STRING
	 */
	protected void sequence_Copyright(EObject context, Copyright semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, ETJPackage.eINSTANCE.getCopyright_Text()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ETJPackage.eINSTANCE.getCopyright_Text()));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getCopyrightAccess().getTextSTRINGTerminalRuleCall_1_0(), semanticObject.getText());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (date=ISODATE description=STRING amount=XFloat)
	 */
	protected void sequence_Credit(EObject context, Credit semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, ETJPackage.eINSTANCE.getCredit_Date()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ETJPackage.eINSTANCE.getCredit_Date()));
			if(transientValues.isValueTransient(semanticObject, ETJPackage.eINSTANCE.getCredit_Description()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ETJPackage.eINSTANCE.getCredit_Description()));
			if(transientValues.isValueTransient(semanticObject, ETJPackage.eINSTANCE.getCredit_Amount()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ETJPackage.eINSTANCE.getCredit_Amount()));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getCreditAccess().getDateISODATEParserRuleCall_1_0(), semanticObject.getDate());
		feeder.accept(grammarAccess.getCreditAccess().getDescriptionSTRINGTerminalRuleCall_2_0(), semanticObject.getDescription());
		feeder.accept(grammarAccess.getCreditAccess().getAmountXFloatParserRuleCall_3_0(), semanticObject.getAmount());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (scenario=[Scenario|ID]? columnId=ColumnId direction=CriterionDirection)
	 */
	protected void sequence_Criterion(EObject context, Criterion semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     currency=STRING
	 */
	protected void sequence_Currency(EObject context, Currency semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, ETJPackage.eINSTANCE.getCurrency_Currency()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ETJPackage.eINSTANCE.getCurrency_Currency()));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getCurrencyAccess().getCurrencySTRINGTerminalRuleCall_1_0(), semanticObject.getCurrency());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     dailyWorkingHours=XFloat
	 */
	protected void sequence_DailyWorkingHours(EObject context, DailyWorkingHours semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, ETJPackage.eINSTANCE.getDailyWorkingHours_DailyWorkingHours()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ETJPackage.eINSTANCE.getDailyWorkingHours_DailyWorkingHours()));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getDailyWorkingHoursAccess().getDailyWorkingHoursXFloatParserRuleCall_1_0(), semanticObject.getDailyWorkingHours());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (all?='*' | none?='-')
	 */
	protected void sequence_Definitions(EObject context, Definitions semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (flags?='flags'? resources?='resources'? tasks?='tasks'? project?='project'? projectids?='projectids'?)
	 */
	protected void sequence_Definitions(EObject context, Defintions semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (dependency+=TaskDependency dependency+=TaskDependency*)
	 */
	protected void sequence_Depends(EObject context, Depends semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (value=XFloat unit=TimeUnit)
	 */
	protected void sequence_DurationQuantity(EObject context, DurationQuantity semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, ETJPackage.eINSTANCE.getDurationQuantity_Value()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ETJPackage.eINSTANCE.getDurationQuantity_Value()));
			if(transientValues.isValueTransient(semanticObject, ETJPackage.eINSTANCE.getDurationQuantity_Unit()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ETJPackage.eINSTANCE.getDurationQuantity_Unit()));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getDurationQuantityAccess().getValueXFloatParserRuleCall_0_0(), semanticObject.getValue());
		feeder.accept(grammarAccess.getDurationQuantityAccess().getUnitTimeUnitEnumRuleCall_1_0(), semanticObject.getUnit());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     duration=DurationQuantity
	 */
	protected void sequence_Duration(EObject context, Duration semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, ETJPackage.eINSTANCE.getDuration_Duration()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ETJPackage.eINSTANCE.getDuration_Duration()));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getDurationAccess().getDurationDurationQuantityParserRuleCall_1_0(), semanticObject.getDuration());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     efficiency=XFloat
	 */
	protected void sequence_Efficiency(EObject context, Efficiency semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, ETJPackage.eINSTANCE.getEfficiency_Efficiency()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ETJPackage.eINSTANCE.getEfficiency_Efficiency()));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getEfficiencyAccess().getEfficiencyXFloatParserRuleCall_1_0(), semanticObject.getEfficiency());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     effort=DurationQuantity
	 */
	protected void sequence_Effort(EObject context, Effort semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, ETJPackage.eINSTANCE.getEffort_Effort()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ETJPackage.eINSTANCE.getEffort_Effort()));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getEffortAccess().getEffortDurationQuantityParserRuleCall_1_0(), semanticObject.getEffort());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     address=STRING
	 */
	protected void sequence_Email(EObject context, Email semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, ETJPackage.eINSTANCE.getEmail_Address()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ETJPackage.eINSTANCE.getEmail_Address()));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getEmailAccess().getAddressSTRINGTerminalRuleCall_1_0(), semanticObject.getAddress());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     credit=XFloat
	 */
	protected void sequence_EndCredit(EObject context, EndCredit semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, ETJPackage.eINSTANCE.getEndCredit_Credit()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ETJPackage.eINSTANCE.getEndCredit_Credit()));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getEndCreditAccess().getCreditXFloatParserRuleCall_1_0(), semanticObject.getCredit());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     end=ISODATE
	 */
	protected void sequence_End(EObject context, End semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, ETJPackage.eINSTANCE.getEnd_End()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ETJPackage.eINSTANCE.getEnd_End()));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getEndAccess().getEndISODATEParserRuleCall_1_0_0(), semanticObject.getEnd());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (id=ID? filename=STRING attributes+=ExportAttribute*)
	 */
	protected void sequence_Export(EObject context, Export semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (extends+=Extend*)
	 */
	protected void sequence_ExtendResource(EObject context, ExtendResource semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (extends+=Extend*)
	 */
	protected void sequence_ExtendTask(EObject context, ExtendTask semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (name=ID description=STRING (inherit?='inherit'? scenariospecific?='scenariospecific'?)?)
	 */
	protected void sequence_Extend(EObject context, Extend semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     extension=[Extend|ID]
	 */
	protected void sequence_ExtendedResourceAttributeColumn(EObject context, ExtendedResourceAttributeColumn semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, ETJPackage.eINSTANCE.getExtendedResourceAttributeColumn_Extension()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ETJPackage.eINSTANCE.getExtendedResourceAttributeColumn_Extension()));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getExtendedResourceAttributeColumnAccess().getExtensionExtendIDTerminalRuleCall_0_1(), semanticObject.getExtension());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (extend=[Extend|QualifiedName] value=STRING)
	 */
	protected void sequence_ExtendedResourceAttribute(EObject context, ExtendedResourceAttribute semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, ETJPackage.eINSTANCE.getExtendedResourceAttribute_Extend()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ETJPackage.eINSTANCE.getExtendedResourceAttribute_Extend()));
			if(transientValues.isValueTransient(semanticObject, ETJPackage.eINSTANCE.getExtendedResourceAttribute_Value()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ETJPackage.eINSTANCE.getExtendedResourceAttribute_Value()));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getExtendedResourceAttributeAccess().getExtendExtendQualifiedNameParserRuleCall_0_0_1(), semanticObject.getExtend());
		feeder.accept(grammarAccess.getExtendedResourceAttributeAccess().getValueSTRINGTerminalRuleCall_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (extend=[Extend|ID] value=STRING)
	 */
	protected void sequence_ExtendedTaskAttribute(EObject context, ExtendedTaskAttribute semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, ETJPackage.eINSTANCE.getExtendedTaskAttribute_Extend()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ETJPackage.eINSTANCE.getExtendedTaskAttribute_Extend()));
			if(transientValues.isValueTransient(semanticObject, ETJPackage.eINSTANCE.getExtendedTaskAttribute_Value()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ETJPackage.eINSTANCE.getExtendedTaskAttribute_Value()));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getExtendedTaskAttributeAccess().getExtendExtendIDTerminalRuleCall_0_0_1(), semanticObject.getExtend());
		feeder.accept(grammarAccess.getExtendedTaskAttributeAccess().getValueSTRINGTerminalRuleCall_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     expression=LogicalExpression
	 */
	protected void sequence_Fail(EObject context, Fail semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, ETJPackage.eINSTANCE.getFail_Expression()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ETJPackage.eINSTANCE.getFail_Expression()));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getFailAccess().getExpressionLogicalExpressionParserRuleCall_1_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (flags+=ID flags+=ID*)
	 */
	protected void sequence_Flags(EObject context, Flags semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     color=STRING
	 */
	protected void sequence_FontColor(EObject context, FontColor semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, ETJPackage.eINSTANCE.getFontColor_Color()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ETJPackage.eINSTANCE.getFontColor_Color()));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getFontColorAccess().getColorSTRINGTerminalRuleCall_1_0(), semanticObject.getColor());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (formats+=ReportFormat formats+=ReportFormat*)
	 */
	protected void sequence_Formats(EObject context, Formats semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (
	 *         (
	 *             (level=INT date=ISODATE?) | 
	 *             scenario=[Scenario|ID] | 
	 *             parentId=ID | 
	 *             (task=[Task|ID] scenario=[Scenario|ID] distance=INT) | 
	 *             (resource=[Resource|ID] scenario=[Scenario|ID]) | 
	 *             (task=[Task|ID] scenario=[Scenario|ID]) | 
	 *             scenario=[Scenario|ID] | 
	 *             scenario=[Scenario|ID] | 
	 *             (resource=[Resource|ID] scenario=[Scenario|ID])
	 *         )?
	 *     )
	 */
	protected void sequence_Function(EObject context, Function semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (project=Project? properties+=Property*)
	 */
	protected void sequence_Global(EObject context, Global semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (expression=LogicalExpression justification=Justification)
	 */
	protected void sequence_HAlign(EObject context, HAlign semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, ETJPackage.eINSTANCE.getHAlign_Expression()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ETJPackage.eINSTANCE.getHAlign_Expression()));
			if(transientValues.isValueTransient(semanticObject, ETJPackage.eINSTANCE.getHAlign_Justification()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ETJPackage.eINSTANCE.getHAlign_Justification()));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getHAlignAccess().getExpressionLogicalExpressionParserRuleCall_0_0(), semanticObject.getExpression());
		feeder.accept(grammarAccess.getHAlignAccess().getJustificationJustificationEnumRuleCall_1_0(), semanticObject.getJustification());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     expression=LogicalFlagExpression
	 */
	protected void sequence_HideAccount(EObject context, HideAccount semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, ETJPackage.eINSTANCE.getHideAccount_Expression()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ETJPackage.eINSTANCE.getHideAccount_Expression()));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getHideAccountAccess().getExpressionLogicalFlagExpressionParserRuleCall_1_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     expression=LogicalFlagExpression
	 */
	protected void sequence_HideJournalEntry(EObject context, HideJournalEntry semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, ETJPackage.eINSTANCE.getHideJournalEntry_Expression()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ETJPackage.eINSTANCE.getHideJournalEntry_Expression()));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getHideJournalEntryAccess().getExpressionLogicalFlagExpressionParserRuleCall_2_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     expression=LogicalExpression
	 */
	protected void sequence_HideReport(EObject context, HideReport semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, ETJPackage.eINSTANCE.getHideReport_Expression()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ETJPackage.eINSTANCE.getHideReport_Expression()));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getHideReportAccess().getExpressionLogicalExpressionParserRuleCall_2_0_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     expression=LogicalExpression
	 */
	protected void sequence_HideResource(EObject context, HideResource semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, ETJPackage.eINSTANCE.getHideResource_Expression()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ETJPackage.eINSTANCE.getHideResource_Expression()));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getHideResourceAccess().getExpressionLogicalExpressionParserRuleCall_2_0_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     expression=LogicalExpression
	 */
	protected void sequence_HideTask(EObject context, HideTask semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, ETJPackage.eINSTANCE.getHideTask_Expression()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ETJPackage.eINSTANCE.getHideTask_Expression()));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getHideTaskAccess().getExpressionLogicalExpressionParserRuleCall_2_0_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (date=ExtDate | (date=ExtDate duration=DurationQuantity))
	 */
	protected void sequence_ISODATE(EObject context, ISODATE semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (filename=STRING attributes+=IcalReportAttribute*)
	 */
	protected void sequence_IcalReport(EObject context, IcalReport semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (importURI=STRING attributes+=IncludePropertiesAttribute*)
	 */
	protected void sequence_IncludeProperties(EObject context, IncludeProperties semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     importURI=STRING
	 */
	protected void sequence_Include(EObject context, Include semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, ETJPackage.eINSTANCE.getInclude_ImportURI()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ETJPackage.eINSTANCE.getInclude_ImportURI()));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getIncludeAccess().getImportURISTRINGTerminalRuleCall_1_0(), semanticObject.getImportURI());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (start=ISODATE (end=ISODATE | duration=DurationQuantity))
	 */
	protected void sequence_Interval1(EObject context, Interval1 semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (start=ISODATE (end=ISODATE | duration=DurationQuantity))
	 */
	protected void sequence_Interval2(EObject context, Interval2 semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (start=ISODATE (end=ISODATE | duration=DurationQuantity)?)
	 */
	protected void sequence_Interval3(EObject context, Interval3 semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (start=ISODATE (end=ISODATE | duration=DurationQuantity)?)
	 */
	protected void sequence_Interval4(EObject context, Interval4 semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (args+=JournalAttributeValues args+=JournalAttributeValues*)
	 */
	protected void sequence_JournalAttributes(EObject context, JournalAttributes semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (date=ISODATE headline=STRING (alert=Alert? author=Author? details=Details? summary=Summary?)?)
	 */
	protected void sequence_JournalEntry(EObject context, JournalEntry semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     mode=JournalModeValue
	 */
	protected void sequence_JournalMode(EObject context, JournalMode semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, ETJPackage.eINSTANCE.getJournalMode_Mode()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ETJPackage.eINSTANCE.getJournalMode_Mode()));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getJournalModeAccess().getModeJournalModeValueEnumRuleCall_1_0(), semanticObject.getMode());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (type=LeaveType (name=ID | name=STRING)? interval=Interval3)
	 */
	protected void sequence_LeaveDetails(EObject context, LeaveDetails semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (details+=LeaveDetails details+=LeaveDetails*)
	 */
	protected void sequence_Leaves(EObject context, Leaves semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     length=DurationQuantity
	 */
	protected void sequence_Length(EObject context, Length semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, ETJPackage.eINSTANCE.getLength_Length()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ETJPackage.eINSTANCE.getLength_Length()));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getLengthAccess().getLengthDurationQuantityParserRuleCall_1_0(), semanticObject.getLength());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (end=ISODATE | period=Interval1 | (resources+=[Resource|ID] resources+=[Resource|ID]*) | start=ISODATE)
	 */
	protected void sequence_LimitAttribute(EObject context, LimitAttribute semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (duration=DurationQuantity attributes+=LimitAttribute*)
	 */
	protected void sequence_Limit(EObject context, Limit semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (attributes+=LimitsAttribute*)
	 */
	protected void sequence_Limits(EObject context, Limits semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     type=ListTypeValues
	 */
	protected void sequence_ListType(EObject context, ListType semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, ETJPackage.eINSTANCE.getListType_Type()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ETJPackage.eINSTANCE.getListType_Type()));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getListTypeAccess().getTypeListTypeValuesEnumRuleCall_1_0(), semanticObject.getType());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     unit=LoadDisplayUnit
	 */
	protected void sequence_LoadUnit(EObject context, LoadUnit semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, ETJPackage.eINSTANCE.getLoadUnit_Unit()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ETJPackage.eINSTANCE.getLoadUnit_Unit()));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getLoadUnitAccess().getUnitLoadDisplayUnitEnumRuleCall_1_0(), semanticObject.getUnit());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     value=AbsoluteId
	 */
	protected void sequence_LogicalAbsoluteIdExpression(EObject context, LogicalAbsoluteIdExression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (leftOperant=LogicalEqualityExpression (op=LEOpAnd rightOperand=LogicalEqualityExpression)?)
	 */
	protected void sequence_LogicalAndExpression(EObject context, LogicalExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (isTrue?='true'?)
	 */
	protected void sequence_LogicalBooleanLiteral(EObject context, LogicalBooleanLiteral semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (leftOperant=LogicalRelationalExpression (op=LEOpEquality rightOperand=LogicalRelationalExpression)?)
	 */
	protected void sequence_LogicalEqualityExpression(EObject context, LogicalExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (scenario=[Scenario|ID] columId=ColumnId)
	 */
	protected void sequence_LogicalFlagLiteral(EObject context, LogicalFlagExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     function=Function
	 */
	protected void sequence_LogicalFunctionExpression(EObject context, LogicalFunctionExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     value=ISODATE
	 */
	protected void sequence_LogicalISODateLiteral(EObject context, LogicalDateLiteral semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     value=XFloat
	 */
	protected void sequence_LogicalNumeralLiteral(EObject context, LogicalNumeralLiteral semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (leftOperant=LogicalAndExpression (op=LEOpOr rightOperand=LogicalAndExpression)?)
	 */
	protected void sequence_LogicalOrExpression(EObject context, LogicalExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (leftOperant=LogicalPrimaryExpression (op=OpCompare rightOperand=LogicalPrimaryExpression)?)
	 */
	protected void sequence_LogicalRelationalExpression(EObject context, LogicalExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (value=STRING | macro=MacroCall)
	 */
	protected void sequence_LogicalStringLiteral(EObject context, LogicalStringLiteral semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (macro=[Macro|QualifiedName] | buildin=BuildInMacro)
	 */
	protected void sequence_MacroCall(EObject context, MacroCall semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (id=ID (value=STRING | properties+=Property)*)
	 */
	protected void sequence_Macro(EObject context, Macro semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (resources+=[Resource|ID] resources+=[Resource|ID]*)
	 */
	protected void sequence_Managers(EObject context, Managers semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     mandatory?='mandatory'
	 */
	protected void sequence_Mandatory(EObject context, Mandatory semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, ETJPackage.eINSTANCE.getMandatory_Mandatory()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ETJPackage.eINSTANCE.getMandatory_Mandatory()));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getMandatoryAccess().getMandatoryMandatoryKeyword_0(), semanticObject.isMandatory());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     maxEnd=ISODATE
	 */
	protected void sequence_MaxEnd(EObject context, MaxEnd semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, ETJPackage.eINSTANCE.getMaxEnd_MaxEnd()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ETJPackage.eINSTANCE.getMaxEnd_MaxEnd()));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getMaxEndAccess().getMaxEndISODATEParserRuleCall_1_0(), semanticObject.getMaxEnd());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     maxStart=ISODATE
	 */
	protected void sequence_MaxStart(EObject context, MaxStart semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, ETJPackage.eINSTANCE.getMaxStart_MaxStart()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ETJPackage.eINSTANCE.getMaxStart_MaxStart()));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getMaxStartAccess().getMaxStartISODATEParserRuleCall_1_0(), semanticObject.getMaxStart());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     milestone?='milestone'
	 */
	protected void sequence_Milestone(EObject context, Milestone semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, ETJPackage.eINSTANCE.getMilestone_Milestone()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ETJPackage.eINSTANCE.getMilestone_Milestone()));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getMilestoneAccess().getMilestoneMilestoneKeyword_0(), semanticObject.isMilestone());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     minEnd=ISODATE
	 */
	protected void sequence_MinEnd(EObject context, MinEnd semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, ETJPackage.eINSTANCE.getMinEnd_MinEnd()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ETJPackage.eINSTANCE.getMinEnd_MinEnd()));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getMinEndAccess().getMinEndISODATEParserRuleCall_1_0(), semanticObject.getMinEnd());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     minStart=ISODATE
	 */
	protected void sequence_MinStart(EObject context, MinStart semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, ETJPackage.eINSTANCE.getMinStart_MinStart()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ETJPackage.eINSTANCE.getMinStart_MinStart()));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getMinStartAccess().getMinStartISODATEParserRuleCall_1_0(), semanticObject.getMinStart());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (id=ID attributes+=NavigatorAttribute*)
	 */
	protected void sequence_Navigator(EObject context, Navigator semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (id=ID text=STRING attributes+=NewTaskAttribute*)
	 */
	protected void sequence_NewTask(EObject context, NewTask semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (filename=STRING attributes+=NikuReportAttribute*)
	 */
	protected void sequence_NikuReport(EObject context, NikuReport semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     note=STRING
	 */
	protected void sequence_Note(EObject context, Note semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, ETJPackage.eINSTANCE.getNote_Note()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ETJPackage.eINSTANCE.getNote_Note()));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getNoteAccess().getNoteSTRINGTerminalRuleCall_1_0(), semanticObject.getNote());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     now=ISODATE
	 */
	protected void sequence_Now(EObject context, Now semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, ETJPackage.eINSTANCE.getNow_Now()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ETJPackage.eINSTANCE.getNow_Now()));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getNowAccess().getNowISODATEParserRuleCall_1_0(), semanticObject.getNow());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     period=Interval2
	 */
	protected void sequence_Period(EObject context, Period semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, ETJPackage.eINSTANCE.getPeriod_Period()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ETJPackage.eINSTANCE.getPeriod_Period()));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getPeriodAccess().getPeriodInterval2ParserRuleCall_1_0(), semanticObject.getPeriod());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     persistent?='persistent'
	 */
	protected void sequence_Persistent(EObject context, Persistent semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, ETJPackage.eINSTANCE.getPersistent_Persistent()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ETJPackage.eINSTANCE.getPersistent_Persistent()));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getPersistentAccess().getPersistentPersistentKeyword_0(), semanticObject.isPersistent());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     priority=INT
	 */
	protected void sequence_Priority(EObject context, Priority semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, ETJPackage.eINSTANCE.getPriority_Priority()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ETJPackage.eINSTANCE.getPriority_Priority()));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getPriorityAccess().getPriorityINTTerminalRuleCall_1_0(), semanticObject.getPriority());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     projectId=ID
	 */
	protected void sequence_ProjectId(EObject context, ProjectId semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, ETJPackage.eINSTANCE.getProjectId_ProjectId()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ETJPackage.eINSTANCE.getProjectId_ProjectId()));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getProjectIdAccess().getProjectIdIDTerminalRuleCall_1_0(), semanticObject.getProjectId());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (ids+=ID ids+=ID*)
	 */
	protected void sequence_ProjectIds(EObject context, ProjectIds semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (id=ID? name=STRING version=STRING? interval=Interval2 attributes+=ProjectAttribute*)
	 */
	protected void sequence_Project(EObject context, Project semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     listAttribute=PurgeReportAttribute
	 */
	protected void sequence_PurgeReport(EObject context, PurgeReport semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, ETJPackage.eINSTANCE.getPurgeReport_ListAttribute()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ETJPackage.eINSTANCE.getPurgeReport_ListAttribute()));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getPurgeReportAccess().getListAttributePurgeReportAttributeEnumRuleCall_1_0(), semanticObject.getListAttribute());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     listAttribute=PurgeResourceAttribute
	 */
	protected void sequence_PurgeResource(EObject context, PurgeResource semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, ETJPackage.eINSTANCE.getPurgeResource_ListAttribute()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ETJPackage.eINSTANCE.getPurgeResource_ListAttribute()));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getPurgeResourceAccess().getListAttributePurgeResourceAttributeEnumRuleCall_1_0(), semanticObject.getListAttribute());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     listAttribute=PurgeTaskAttribute
	 */
	protected void sequence_PurgeTask(EObject context, PurgeTask semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, ETJPackage.eINSTANCE.getPurgeTask_ListAttribute()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ETJPackage.eINSTANCE.getPurgeTask_ListAttribute()));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getPurgeTaskAccess().getListAttributePurgeTaskAttributeEnumRuleCall_1_0(), semanticObject.getListAttribute());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     value=STRING
	 */
	protected void sequence_RGB(EObject context, RGB semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, ETJPackage.eINSTANCE.getRGB_Value()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ETJPackage.eINSTANCE.getRGB_Value()));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getRGBAccess().getValueSTRINGTerminalRuleCall_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     rate=XFloat
	 */
	protected void sequence_Rate(EObject context, Rate semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, ETJPackage.eINSTANCE.getRate_Rate()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ETJPackage.eINSTANCE.getRate_Rate()));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getRateAccess().getRateXFloatParserRuleCall_1_0(), semanticObject.getRate());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (negativePrefix=STRING negativeSuffix=STRING thousandsSeparator=STRING fractionSeparator=STRING fractionDigits=INT)
	 */
	protected void sequence_RealFormat(EObject context, RealFormat semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, ETJPackage.eINSTANCE.getRealFormat_NegativePrefix()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ETJPackage.eINSTANCE.getRealFormat_NegativePrefix()));
			if(transientValues.isValueTransient(semanticObject, ETJPackage.eINSTANCE.getRealFormat_NegativeSuffix()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ETJPackage.eINSTANCE.getRealFormat_NegativeSuffix()));
			if(transientValues.isValueTransient(semanticObject, ETJPackage.eINSTANCE.getRealFormat_ThousandsSeparator()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ETJPackage.eINSTANCE.getRealFormat_ThousandsSeparator()));
			if(transientValues.isValueTransient(semanticObject, ETJPackage.eINSTANCE.getRealFormat_FractionSeparator()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ETJPackage.eINSTANCE.getRealFormat_FractionSeparator()));
			if(transientValues.isValueTransient(semanticObject, ETJPackage.eINSTANCE.getRealFormat_FractionDigits()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ETJPackage.eINSTANCE.getRealFormat_FractionDigits()));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getRealFormatAccess().getNegativePrefixSTRINGTerminalRuleCall_0_0(), semanticObject.getNegativePrefix());
		feeder.accept(grammarAccess.getRealFormatAccess().getNegativeSuffixSTRINGTerminalRuleCall_1_0(), semanticObject.getNegativeSuffix());
		feeder.accept(grammarAccess.getRealFormatAccess().getThousandsSeparatorSTRINGTerminalRuleCall_2_0(), semanticObject.getThousandsSeparator());
		feeder.accept(grammarAccess.getRealFormatAccess().getFractionSeparatorSTRINGTerminalRuleCall_3_0(), semanticObject.getFractionSeparator());
		feeder.accept(grammarAccess.getRealFormatAccess().getFractionDigitsINTTerminalRuleCall_4_0(), semanticObject.getFractionDigits());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     remaining=DurationQuantity
	 */
	protected void sequence_Remaining(EObject context, Remaining semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, ETJPackage.eINSTANCE.getRemaining_Remaining()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ETJPackage.eINSTANCE.getRemaining_Remaining()));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getRemainingAccess().getRemainingDurationQuantityParserRuleCall_1_0(), semanticObject.getRemaining());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     report=[Report|ID]
	 */
	protected void sequence_ReportPrefix(EObject context, ReportPrefix semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, ETJPackage.eINSTANCE.getReportPrefix_Report()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ETJPackage.eINSTANCE.getReportPrefix_Report()));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getReportPrefixAccess().getReportReportIDTerminalRuleCall_1_0_1(), semanticObject.getReport());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (id=ID? name=STRING attributes+=ReportAttribute*)
	 */
	protected void sequence_Report(EObject context, Report semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (vacation?='vacation'? booking?='booking'? workingHours?='workinghours'?)
	 */
	protected void sequence_ResourceAttributes(EObject context, ResourceAttributes semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     resource=[Resource|ID]
	 */
	protected void sequence_ResourcePrefix(EObject context, ResourcePrefix semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, ETJPackage.eINSTANCE.getResourcePrefix_Resource()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ETJPackage.eINSTANCE.getResourcePrefix_Resource()));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getResourcePrefixAccess().getResourceResourceIDTerminalRuleCall_1_0_1(), semanticObject.getResource());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     resource=[Resource|ID]
	 */
	protected void sequence_ResourceRoot(EObject context, ResourceRoot semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, ETJPackage.eINSTANCE.getResourceRoot_Resource()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ETJPackage.eINSTANCE.getResourceRoot_Resource()));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getResourceRootAccess().getResourceResourceIDTerminalRuleCall_1_0_1(), semanticObject.getResource());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (id=ID? name=STRING attributes+=ResourceAttribute*)
	 */
	protected void sequence_Resource(EObject context, Resource semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (resources+=[Resource|ID] resources+=[Resource|ID]*)
	 */
	protected void sequence_Responsible(EObject context, Responsible semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     text=STRING
	 */
	protected void sequence_RichText(EObject context, RichText semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, ETJPackage.eINSTANCE.getRichText_Text()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ETJPackage.eINSTANCE.getRichText_Text()));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getRichTextAccess().getTextSTRINGTerminalRuleCall_0(), semanticObject.getText());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     expression=LogicalExpression
	 */
	protected void sequence_RollupAccount(EObject context, RollupAccount semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, ETJPackage.eINSTANCE.getRollupAccount_Expression()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ETJPackage.eINSTANCE.getRollupAccount_Expression()));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getRollupAccountAccess().getExpressionLogicalExpressionParserRuleCall_1_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     expression=LogicalExpression
	 */
	protected void sequence_RollupResource(EObject context, RollupResource semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, ETJPackage.eINSTANCE.getRollupResource_Expression()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ETJPackage.eINSTANCE.getRollupResource_Expression()));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getRollupResourceAccess().getExpressionLogicalExpressionParserRuleCall_1_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     expression=LogicalExpression
	 */
	protected void sequence_RollupTask(EObject context, RollupTask semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, ETJPackage.eINSTANCE.getRollupTask_Expression()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ETJPackage.eINSTANCE.getRollupTask_Expression()));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getRollupTaskAccess().getExpressionLogicalExpressionParserRuleCall_1_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (
	 *         scale='hour' | 
	 *         scale='day' | 
	 *         scale='week' | 
	 *         scale='month' | 
	 *         scale='quarter' | 
	 *         scale='year'
	 *     )
	 */
	protected void sequence_Scale(EObject context, Scale semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     scenario=[Scenario|ID]
	 */
	protected void sequence_ScenarioIcal(EObject context, ScenarioIcal semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, ETJPackage.eINSTANCE.getScenarioIcal_Scenario()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ETJPackage.eINSTANCE.getScenarioIcal_Scenario()));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getScenarioIcalAccess().getScenarioScenarioIDTerminalRuleCall_1_0_1(), semanticObject.getScenario());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (id=ID name=STRING (active=YesNo? scenario=Scenario?)?)
	 */
	protected void sequence_Scenario(EObject context, Scenario semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (scenarios+=[Scenario|ID] scenarios+=[Scenario|ID]*)
	 */
	protected void sequence_Scenarios(EObject context, Scenarios semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     scheduled?='scheduled'
	 */
	protected void sequence_Scheduled(EObject context, Scheduled semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, ETJPackage.eINSTANCE.getScheduled_Scheduled()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ETJPackage.eINSTANCE.getScheduled_Scheduled()));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getScheduledAccess().getScheduledScheduledKeyword_0(), semanticObject.isScheduled());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     scheduling=SchedulingPolicy
	 */
	protected void sequence_Scheduling(EObject context, Scheduling semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, ETJPackage.eINSTANCE.getScheduling_Scheduling()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ETJPackage.eINSTANCE.getScheduling_Scheduling()));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getSchedulingAccess().getSchedulingSchedulingPolicyEnumRuleCall_1_0(), semanticObject.getScheduling());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     argument=SelectArgument
	 */
	protected void sequence_Select(EObject context, Select semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, ETJPackage.eINSTANCE.getSelect_Argument()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ETJPackage.eINSTANCE.getSelect_Argument()));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getSelectAccess().getArgumentSelectArgumentEnumRuleCall_1_0(), semanticObject.getArgument());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     selfcontained=YesNo
	 */
	protected void sequence_SelfContained(EObject context, SelfContained semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, ETJPackage.eINSTANCE.getSelfContained_Selfcontained()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ETJPackage.eINSTANCE.getSelfContained_Selfcontained()));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getSelfContainedAccess().getSelfcontainedYesNoEnumRuleCall_1_0(), semanticObject.getSelfcontained());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     shift=[Shift|ID]
	 */
	protected void sequence_ShiftTimesheet(EObject context, ShiftTimesheet semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, ETJPackage.eINSTANCE.getShiftTimesheet_Shift()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ETJPackage.eINSTANCE.getShiftTimesheet_Shift()));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getShiftTimesheetAccess().getShiftShiftIDTerminalRuleCall_1_0_1(), semanticObject.getShift());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (id=ID? name=STRING (replace='replace'? timezone=STRING? vacation=VacationShift? shift=Shift? workingHours=WorkingHours?)?)
	 */
	protected void sequence_Shift(EObject context, Shift semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (shift=[Shift|ID] (intervals+=Interval3 intervals+=Interval3*)?)
	 */
	protected void sequence_ShiftsAllocate(EObject context, ShiftsAllocate semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (shift=[Shift|ID] limit=Interval2?)
	 */
	protected void sequence_ShiftsLimit(EObject context, ShiftsLimit semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (limits+=ShiftsLimit limits+=ShiftsLimit*)
	 */
	protected void sequence_Shifts(EObject context, Shifts semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     shortTimeFormat=STRING
	 */
	protected void sequence_ShortTimeFormat(EObject context, ShortTimeFormat semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, ETJPackage.eINSTANCE.getShortTimeFormat_ShortTimeFormat()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ETJPackage.eINSTANCE.getShortTimeFormat_ShortTimeFormat()));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getShortTimeFormatAccess().getShortTimeFormatSTRINGTerminalRuleCall_1_0(), semanticObject.getShortTimeFormat());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     ((tree?='tree'? | criteria+=Criterion) criteria+=Criterion*)
	 */
	protected void sequence_Sort(EObject context, Sort semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     start=ISODATE
	 */
	protected void sequence_Start(EObject context, Start semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, ETJPackage.eINSTANCE.getStart_Start()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ETJPackage.eINSTANCE.getStart_Start()));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getStartAccess().getStartISODATEParserRuleCall_1_0_0(), semanticObject.getStart());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (filename=STRING attributes+=StatusSheetReportAttribute*)
	 */
	protected void sequence_StatusSheetReport(EObject context, StatusSheetReport semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (resource=[Resource|ID] interval=Interval4 attributes+=StatusSheetAttribute*)
	 */
	protected void sequence_StatusSheet(EObject context, StatusSheet semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (level=AlertLevel text=STRING attributes+=StatusStatusSheetAttribute*)
	 */
	protected void sequence_StatusStatusSheet(EObject context, StatusStatusSheet semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (level=AlertLevel text=STRING attributes+=StatusTimesheetAttribute*)
	 */
	protected void sequence_StatusTimesheet(EObject context, StatusTimesheet semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (account=[Account|ID] attributes+=AccountAttribute*)
	 */
	protected void sequence_SupplementAccount(EObject context, SupplementAccount semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (report=[Report|ID] attributes+=ReportAttribute*)
	 */
	protected void sequence_SupplementReport(EObject context, SupplementReport semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (resource=[Resource|ID] attributes+=ResourceAttribute*)
	 */
	protected void sequence_SupplementResource(EObject context, SupplementResource semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (task=[Task|TaskPath] attributes+=TaskAttribute*)
	 */
	protected void sequence_SupplementTask(EObject context, SupplementTask semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (id=ID? filename=STRING (hideResource=HideResource? hideTask=HideTask? rollupResource=RollupResource? rollupTask=RollupTask?)?)
	 */
	protected void sequence_TagFile(EObject context, TagFile semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (
	 *         scenario=[Scenario|QualifiedName]? 
	 *         (
	 *             attr=Allocate | 
	 *             attr=BookingTask | 
	 *             attr=Charge | 
	 *             attr=ChargeSet | 
	 *             attr=Complete | 
	 *             attr=Depends | 
	 *             attr=Duration | 
	 *             attr=Effort | 
	 *             attr=End | 
	 *             attr=EndCredit | 
	 *             attr=ExtendedTaskAttribute | 
	 *             attr=Fail | 
	 *             attr=Flags | 
	 *             attr=JournalEntry | 
	 *             attr=Length | 
	 *             attr=Limits | 
	 *             attr=MaxEnd | 
	 *             attr=MaxStart | 
	 *             attr=Milestone | 
	 *             attr=MinEnd | 
	 *             attr=MinStart | 
	 *             attr=Note | 
	 *             attr=Period | 
	 *             attr=Precedes | 
	 *             attr=Priority | 
	 *             attr=ProjectId | 
	 *             attr=PurgeTask | 
	 *             attr=Responsible | 
	 *             attr=Scheduled | 
	 *             attr=Scheduling | 
	 *             attr=ShiftsTask | 
	 *             attr=Start | 
	 *             attr=SupplementTask | 
	 *             attr=Task | 
	 *             attr=Warn | 
	 *             attr=MacroCall
	 *         )
	 *     )
	 */
	protected void sequence_TaskAttribute(EObject context, TaskAttribute semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (
	 *         responsible?='responsible'? 
	 *         flags?='flags'? 
	 *         maxstart?='maxstart'? 
	 *         maxend?='maxend'? 
	 *         priority?='priority'? 
	 *         booking?='booking'? 
	 *         note?='note'? 
	 *         minstart?='minstart'? 
	 *         minend?='minend'? 
	 *         complete?='complete'? 
	 *         depends?='depends'?
	 *     )
	 */
	protected void sequence_TaskAttributes(EObject context, TaskAttributes semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (task=[Task|TaskPath] (gapDuration=GapDuration? gapLength=GapLength? policy=DependsPolicy?)?)
	 */
	protected void sequence_TaskDependency(EObject context, TaskDependency semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     task=[Task|ID]
	 */
	protected void sequence_TaskPrefix(EObject context, TaskPrefix semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, ETJPackage.eINSTANCE.getTaskPrefix_Task()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ETJPackage.eINSTANCE.getTaskPrefix_Task()));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getTaskPrefixAccess().getTaskTaskIDTerminalRuleCall_1_0_1(), semanticObject.getTask());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     task=[Task|AbsoluteId]
	 */
	protected void sequence_TaskRoot(EObject context, TaskRoot semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, ETJPackage.eINSTANCE.getTaskRoot_Task()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ETJPackage.eINSTANCE.getTaskRoot_Task()));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getTaskRootAccess().getTaskTaskAbsoluteIdParserRuleCall_1_0_1(), semanticObject.getTask());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (task=[Task|AbsoluteId] attributes+=TaskStatusSheetAttribute*)
	 */
	protected void sequence_TaskStatusSheet(EObject context, TaskStatusSheet semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (task=[Task|ID] attributes+=TaskTimesheetAttribute*)
	 */
	protected void sequence_TaskTimesheet(EObject context, TaskTimesheet semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (id=ID? name=STRING attributes+=TaskAttribute*)
	 */
	protected void sequence_Task(EObject context, Task semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     timeformat=STRING
	 */
	protected void sequence_TimeFormat(EObject context, TimeFormat semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, ETJPackage.eINSTANCE.getTimeFormat_Timeformat()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ETJPackage.eINSTANCE.getTimeFormat_Timeformat()));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getTimeFormatAccess().getTimeformatSTRINGTerminalRuleCall_1_0(), semanticObject.getTimeformat());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (id=STRING name=STRING)
	 */
	protected void sequence_Timeoff(EObject context, Timeoff semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, ETJPackage.eINSTANCE.getTimeoff_Id()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ETJPackage.eINSTANCE.getTimeoff_Id()));
			if(transientValues.isValueTransient(semanticObject, ETJPackage.eINSTANCE.getTimeoff_Name()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ETJPackage.eINSTANCE.getTimeoff_Name()));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getTimeoffAccess().getIdSTRINGTerminalRuleCall_1_0(), semanticObject.getId());
		feeder.accept(grammarAccess.getTimeoffAccess().getNameSTRINGTerminalRuleCall_2_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (filename=STRING attributes+=TimesheetReportAttribute*)
	 */
	protected void sequence_TimesheetReport(EObject context, TimesheetReport semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (resource=[Resource|ID] interval=Interval4 attributes+=TimesheetAttribute*)
	 */
	protected void sequence_Timesheet(EObject context, Timesheet semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     timezone=STRING
	 */
	protected void sequence_Timezone(EObject context, Timezone semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, ETJPackage.eINSTANCE.getTimezone_Timezone()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ETJPackage.eINSTANCE.getTimezone_Timezone()));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getTimezoneAccess().getTimezoneSTRINGTerminalRuleCall_1_0(), semanticObject.getTimezone());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     timingResolution=INT
	 */
	protected void sequence_TimingResolution(EObject context, TimingResolution semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, ETJPackage.eINSTANCE.getTimingResolution_TimingResolution()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ETJPackage.eINSTANCE.getTimingResolution_TimingResolution()));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getTimingResolutionAccess().getTimingResolutionINTTerminalRuleCall_1_0(), semanticObject.getTimingResolution());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     title=STRING
	 */
	protected void sequence_Title(EObject context, Title semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, ETJPackage.eINSTANCE.getTitle_Title()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ETJPackage.eINSTANCE.getTitle_Title()));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getTitleAccess().getTitleSTRINGTerminalRuleCall_1_0(), semanticObject.getTitle());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (expression=LogicalExpression tip=STRING)
	 */
	protected void sequence_ToolTip(EObject context, ToolTip semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, ETJPackage.eINSTANCE.getToolTip_Expression()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ETJPackage.eINSTANCE.getToolTip_Expression()));
			if(transientValues.isValueTransient(semanticObject, ETJPackage.eINSTANCE.getToolTip_Tip()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ETJPackage.eINSTANCE.getToolTip_Tip()));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getToolTipAccess().getExpressionLogicalExpressionParserRuleCall_1_0(), semanticObject.getExpression());
		feeder.accept(grammarAccess.getToolTipAccess().getTipSTRINGTerminalRuleCall_2_0(), semanticObject.getTip());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     scenario=[Scenario|ID]
	 */
	protected void sequence_TrackingScenario(EObject context, TrackingScenario semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, ETJPackage.eINSTANCE.getTrackingScenario_Scenario()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ETJPackage.eINSTANCE.getTrackingScenario_Scenario()));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getTrackingScenarioAccess().getScenarioScenarioIDTerminalRuleCall_1_0_1(), semanticObject.getScenario());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     level=STRING
	 */
	protected void sequence_TreeLevel(EObject context, TreeLevel semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, ETJPackage.eINSTANCE.getTreeLevel_Level()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ETJPackage.eINSTANCE.getTreeLevel_Level()));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getTreeLevelAccess().getLevelSTRINGTerminalRuleCall_1_0(), semanticObject.getLevel());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (name=STRING? intervals+=Interval3 intervals+=Interval3*)
	 */
	protected void sequence_VacationResource(EObject context, Vacation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (name=STRING? (intervals+=Interval3 intervals+=Interval3*)?)
	 */
	protected void sequence_VacationShift(EObject context, Vacation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (name=STRING intervals+=Interval3 intervals+=Interval3*)
	 */
	protected void sequence_Vacation(EObject context, Vacation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     expression=LogicalExpression
	 */
	protected void sequence_Warn(EObject context, Warn semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, ETJPackage.eINSTANCE.getWarn_Expression()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ETJPackage.eINSTANCE.getWarn_Expression()));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getWarnAccess().getExpressionLogicalExpressionParserRuleCall_1_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (sunday?='weekstartssunday' | monday?='weekstartsmonday')
	 */
	protected void sequence_WeekStarts(EObject context, WeekStarts semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (first=Weekday last=Weekday?)
	 */
	protected void sequence_Weekdays(EObject context, Weekdays semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     width=XFloat
	 */
	protected void sequence_Width(EObject context, Width semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, ETJPackage.eINSTANCE.getWidth_Width()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ETJPackage.eINSTANCE.getWidth_Width()));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getWidthAccess().getWidthXFloatParserRuleCall_1_0(), semanticObject.getWidth());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (start=TIME stop=TIME)
	 */
	protected void sequence_WorkHours(EObject context, WorkHours semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, ETJPackage.eINSTANCE.getWorkHours_Start()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ETJPackage.eINSTANCE.getWorkHours_Start()));
			if(transientValues.isValueTransient(semanticObject, ETJPackage.eINSTANCE.getWorkHours_Stop()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ETJPackage.eINSTANCE.getWorkHours_Stop()));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getWorkHoursAccess().getStartTIMETerminalRuleCall_0_0(), semanticObject.getStart());
		feeder.accept(grammarAccess.getWorkHoursAccess().getStopTIMETerminalRuleCall_2_0(), semanticObject.getStop());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (value=XFloat unit=WorkQuantityUnit)
	 */
	protected void sequence_Work(EObject context, Work semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, ETJPackage.eINSTANCE.getWork_Value()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ETJPackage.eINSTANCE.getWork_Value()));
			if(transientValues.isValueTransient(semanticObject, ETJPackage.eINSTANCE.getWork_Unit()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ETJPackage.eINSTANCE.getWork_Unit()));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getWorkAccess().getValueXFloatParserRuleCall_1_0(), semanticObject.getValue());
		feeder.accept(grammarAccess.getWorkAccess().getUnitWorkQuantityUnitEnumRuleCall_2_0(), semanticObject.getUnit());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (weekdays+=Weekdays weekdays+=Weekdays* (off?='off' | (hours+=WorkHours hours+=WorkHours*)))
	 */
	protected void sequence_WorkingHours(EObject context, WorkingHours semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     yearlyWorkingDays=INT
	 */
	protected void sequence_YearlyWorkingDays(EObject context, YearlyWorkingDays semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, ETJPackage.eINSTANCE.getYearlyWorkingDays_YearlyWorkingDays()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ETJPackage.eINSTANCE.getYearlyWorkingDays_YearlyWorkingDays()));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getYearlyWorkingDaysAccess().getYearlyWorkingDaysINTTerminalRuleCall_1_0(), semanticObject.getYearlyWorkingDays());
		feeder.finish();
	}
}
